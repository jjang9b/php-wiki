<!DOCTYPE html>
<html>
<head>
</head>
<body>
<span style="color: #993300;"><span style="color: #993300;"><span style="color: #993300;"><strong>[기본] commonJS - nodeJS 로딩 이해</strong><br /><br /><span style="color: #000000;">nodeJS가 가장 대표적인 commonJS 규격으로 개발된 framework 이며 </span><br /><span style="color: #000000;">ServerSide에서 사용되는 부분을 브라우저로 구현해 보았다.</span><br /><br /><span style="color: #000000;">실제로는 v8 엔진을 통해 js를 로드하는 부분들은 직접 파일을 로드하게 되는데, </span><br /><span style="color: #000000;">이부분은 eval()을 통해&nbsp;간접 구현.&nbsp;</span><br /><br /><span style="color: #000000;">코드를 파악해 보면 전체적 nodeJS의 commonJS 규격에 맞춘 모듈 로드 형태가 파악됨.<br /></span></span></span></span>
<pre><code class="html">&lt;!-- 1.html  --&gt;<br />&lt;!DOCYTYPE&gt;<br />&lt;html&gt;<br />&lt;head&gt;<br /> &lt;script src="node.js"&gt;&lt;/script&gt;<br /> &lt;script type="text/javascript"&gt;<br /> var main = require( 'main' );<br /> main.socketOpen();<br /> // Console.log : socket open<br /> &lt;/script&gt;<br />&lt;/head&gt;<br />&lt;/html&gt;</code></pre>
<pre><code>// node.js<br />(function( _this ){<br /> function Module( id ){<br />&nbsp; this.id = id;<br />&nbsp; this.exports = {};<br /> };<br /><br /> /* 1. compile 을 통해 module을 로드 및 exports / require 함수 전역화 */<br /> Module.prototype = {<br />&nbsp; compile : function(){<br />&nbsp; &nbsp; (function( exports, id ){<br />&nbsp; &nbsp; &nbsp; _this.exports = exports;<br />&nbsp; &nbsp; &nbsp; Module.evalScript( id );<br /><br />&nbsp; &nbsp; })( this.exports, this.id );<br />&nbsp; }<br /> };<br /><br /> /* 2. node.js와 같이 server에서 직접 로드 방식 eval()로 구현 */<br /> Module.evalScript= function( file ){<br />&nbsp; var xhr = null<br />&nbsp; , url = file + '.js';<br /><br />&nbsp; if ( _this.XMLHttpRequest ) {<br />&nbsp; &nbsp; xhr = new window.XMLHttpRequest();<br />&nbsp; } else if ( _this.ActiveXObject ){<br />&nbsp; &nbsp; xhr = new window.ActiveXObject( 'Microsoft.XMLHTTP' );<br />&nbsp; }<br /><br />&nbsp; xhr.open( 'GET', url, false );<br />&nbsp; xhr.setRequestHeader('Content-type', 'text/html' );<br />&nbsp; xhr.onreadystatechange = function(){<br />&nbsp; &nbsp; if( xhr.readyState == 4 ){<br />&nbsp; &nbsp; &nbsp; switch( xhr.status ){<br />&nbsp; &nbsp; &nbsp; case 200 :<br />&nbsp; &nbsp; &nbsp; &nbsp; eval( xhr.responseText );<br />&nbsp; &nbsp; &nbsp; &nbsp; break;<br />&nbsp; &nbsp; &nbsp; }<br />&nbsp; &nbsp; }<br />&nbsp; }<br />&nbsp; &nbsp; &nbsp; xhr.send();<br /> };<br /><br /> /* 3. 전역 함수 require 정의 */<br /> Module.require = function( id ){<br />&nbsp; var module = new Module( id );<br />&nbsp; module.compile();<br /><br />&nbsp; return module.exports;<br /> };<br /><br /> /* 4. 메인 start 함수 실행 */<br /> function start(){};<br /> start();<br /> _this.require = require;<br /><br />})( window );<br />
</code></pre>
<pre><code class="javascript">// main.js<br />(function( exports ){<br />  var socket = require( 'socket' );<br />  function <span>socketOpen</span>(){<br />   socket.open();<br />  };<br />  exports.socketOpen = socketOpen; <br />})( <br /> typeof exports !== undefined ? exports : {}<br />);</code></pre>
<pre><code class="javascript">// socket.js<br />function open(){<br />&nbsp;console.log( 'socket open' );<br />};<br />exports.open = open;</code></pre>
<br /><br /> 가장 중요한 부분은 결국 require() 함수를 전역으로 쓸수 있게 하며 <span style="color: #993300;"><strong>module.exports </strong><span style="color: #000000;">객체가 return 된다는 점이다.<br /></span></span>전역 exports 속성에 각 모듈을 추가하여 정의하도록 하며, 실제 return은 module.exports를 통해 <br />call by reference 의 규약을 갖도록 약속하고 있다. <br /><br />1. node.js 를 통해 Module 함수객체(class) 를 선언하며 require() 함수를 정의한다.<br />해당 함수에서 Module 객체를 new 생성하며 로드하려는 모듈 id를 정의한다.<br /><br />2. new를 통해 module.compile() 이란 prototype 속성에 접근하며,&nbsp;<br />evalScript()를 통해 별도의 js모듈 파일을 로드한다. 이때 각 모듈이 exports 참조에 자신의 모듈을 추가하게 된다.<br /><br />3. 이후 return module.exports를 하게 되면 2번에서 추가된 exports참조 값을 리턴하게 되어<br />해당 모듈을 리턴 받게 된다. <br /><br />@실제로는 require() 하는 당시 내부 cache를 쓰는 부분이 추가되어 있다.
</body>
</html>